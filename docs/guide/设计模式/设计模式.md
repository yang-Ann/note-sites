---
title: 设计模式
date: 2022-3-5
categories:
 - 编程干货
tags:
 - 设计模式
---
:::v-pre



# 设计模式



[[toc]]

## 设计模式

    设计模式(Design Pattern)就是在软件设计, 开发过程中, 针对特定问题, 场景的更优解决方案
    设计模式的核心操作是去观察你整个逻辑里面的变与不变, 然后将变与不变分离, 达到使变化的部分灵活, 不变的地方稳定的目的

### 设计原则
- 单一职责原则(SRP)
    - 一个对象或方法只做一件事情, 如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大
    - 应该把对象或方法划分成较小的粒度

- 开放-封闭原则(OCP)
    - 软件实体 (类、模块、函数) 等应该是可以扩展的，但是不可修改
    - 当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定

- 最少知识原则(LKP)
    - 一个软件实体应当尽可能少地与其他实体发生关联和依赖
    - 应当尽量减少对象之间的交互, 如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互关联，可以转交给第三方进行处理

- 里氏替换原则(LSP)
  - 子类应该可以完全替换父类
  - 在使用继承时, 只扩展新功能, 而不要破坏父类原有的功能
  
- 依赖倒置原则(DIP)
  - 细节应该依赖于抽象, 抽象不应依赖于细节
  - 把抽象层放在程序设计的高层, 并保持稳定, 程序的细节变化由低层的实现层来完成

### 设计模式分类 
- 创建型设计模式
- 结构型设计模式 
- 行为型设计模式


## 构造器模式
    把对象中的共同属性写到一个父类, 使用 new 来统一构造实例

  ```js
  // 把人共有的属性(姓名, 年龄, 性别) 提取成一个人的类
  class Person {
      constructor(name, age, sex) {
          this.name = name;
          this.age = age;
          this.sex = sex;
      }
      // 输出个人信息
      myInfo() {
          console.log(`我叫${this.name},年龄${this.age},性别${this.sex}`);
      }
  }
  // 每次需要一个表示人的对象时, 就 new 一个
  const p1 = new Person('张三', 18, '男');
  const p2 = new Person('李四', 19, '男');
  const p3 = new Person('小红', 20, '女');
  
  [p1, p2, p3].forEach(item => {
      item.myInfo();
      /* 
          我叫张三,年龄18,性别男
          我叫李四,年龄19,性别男
          我叫小红,年龄20,性别女
      */
  })
  ```

##  建造者模式
    将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

  ```js
  /* 
      例子:
          建一个房子, 里面有卧室 厨房 厕所
  
      建造者模式(实现思路)
          需要一个包工头类 来调用 工人类来建造需要的东西 
  */
  
  // 包工头
  class Bgt {
      constructor(data) {
          this.fz = data;
          console.log('我需要这样的房子',data);
      }
      // 包工头建造方法
      build() {
          console.log('开始建造');
          // map 对每一项进行处理
          const fz = this.fz.map(item => {
              // new 一个工人
              const gr = new Gr();
              // 开工
              gr.build(item);
              return gr;
          });
          console.log('房子建好了');
          console.log(fz);
      }
  }
  
  // 工人
  class Gr {
      // 工人建造方法
      build(val) {
          console.log('开始建造', val);
          // ....
          console.log('建造完成', val);
          this.data = val;
      }
  }
  
  // 告知房子要求
  const bgt = new Bgt(['卧室', '厨房', '厕所']);
  // 开始建造
  bgt.build();
  /*
      我需要这样的房子 (3) ['卧室', '厨房', '厕所']
      开始建造
      开始建造 卧室
      建造完成 卧室
      开始建造 厨房
      建造完成 厨房
      开始建造 厕所
      建造完成 厕所
      房子建好了
      (3) [Gr, Gr, Gr]
      	0: Gr {data: '卧室'}
          1: Gr {data: '厨房'}
          2: Gr {data: '厕所'}
  */
  ```

## 工厂模式

### 普通工厂
    简单工厂模式中，可以根据参数的不同创建不同信息的实例

```js
/* 
    例子: 
        需要批量创建学生信息
            有名字, 学科信息...
        如果一次一次的 new 太麻烦了, 这时候可以使用工厂模式 
*/


// 创建一个表示学生信息的类
class Student {
    constructor(name, subjects) {
        this.name = name;
        // 文科生: ['政治', '历史', '地理']
        // 理科 ...
        // 体育 ...
        this.subjects = subjects;
    }
}

// 创建一个工厂函数来创建学生信息(根据参数的不同创建不同信息的对象)
function factory(name, type) {
    switch (type) {
        case '文科':
            return new Student(name, ['政治', '历史', '地理']);
            break;
        case '理科':
            return new Student(name, ['数学', '物理', '化学']);
            break;
        case '体育':
            return new Student(name, ['长跑', '短跑', '跳高']);
            break;
        default:
            throw `没有这个专业--->${type}`;
    }
}
console.log(factory('小明','文科')); // name: "小明" subjects: (3) ['政治', '历史', '地理']
console.log(factory('小红','理科')); // name: "小红" subjects: (3) ['数学', '物理', '化学']
console.log(factory('小亮','体育')); // name: "小亮" subjects: (3) ['长跑', '短跑', '跳高']
console.log(factory('小田','美术')); // Uncaught 没有这个专业--->美术
```

### 抽象工厂
    抽象工厂模式中, 有一个抽象工厂函数, 可以根据参数的不同返回不同的工厂函数, 随时切换需要的工厂类

```js
/* 
    例子: 
        现在不止要批量创建学生的信息
            还要批量创建老师的信息
        这时候工厂模式就不适合了, 要使用抽象工厂模式 
*/


// 表示学生信息的类
class Student {
    constructor() {
        this.info = '我是个学生';
    }
}

// 表示老师信息的类
class Teacher {
    constructor() {
        this.info = '我是个老师';
    }
}

// 学生信息工厂函数
function studentFactory() {
    return new Student();

}
// 老师信息工厂函数
function teacherFactory() {
    return new Teacher();
}

/*
    抽象工厂函数
        根据参数, 返回不同的工厂
*/
function userProducer(factory) {
    switch (factory) {
        case 'student':
            return studentFactory;
            break
        case 'teacher':
            return teacherFactory;
            break
        default:
            throw `没有这个工厂 --> ${factory}`;
    }
}

const student = userProducer('student'); // 返回学生工厂函数
const teacher = userProducer('teacher'); // 返回老师工厂函数
const s = student(); // 调用获得学生对象
const t = teacher(); // 调用获得老师对象
console.log(s); // Student {info: '我是个学生'}
console.log(t); // Teacher {info: '我是个老师'}
```

## 单例模式
    保证一个类仅有一个实例，并提供一个可以全局访问它的唯一对象
    实现的方法为先判断实例存在与否，如果不存在就创建保存，如果存在则直接返回，这就确保了一个类只有一个实例对象

```js
class Fn{
    constructor(){
        // 判断 类本身的 instance 有没有
        if(Fn.instance){
            // 有则返回
            return Fn.instance;
        }else{
            // 没有则赋值 this
            Fn.instance = this;
        }
    }
}

const f1 = new Fn();
const f2 = new Fn();
console.log(f1 === f2); // true
```


## 装饰者模式
    向一个现有的对象添加新的功能，同时又不改变其结构
    重写新的逻辑方法, 调用旧的逻辑方法, 加上新的需求逻辑

```js
<button class="btn">按钮</button>
<script>
/* 
    例子:
        现在有个点击按钮原来已经写了很多很多代码逻辑了
            现在新增一个需求, 就是点击按钮要有个弹窗, 背景色变红
*/

const btn = document.querySelector('.btn');

// 以前写的很多很多逻辑
btn.onclick = handleA;
function handleA() {
    console.log('这里发送登录请求');
    console.log('这里保存返回数据');
    console.log('...');
    // ...
}


// 装饰者模式
// 新的方法
function newHandleA() {
    // 调用旧的逻辑方法
    handleA();

    // 加上新的操作
    alert('hello');
    document.body.style.backgroundColor = '#f00';
}

// 绑定事件 
btn.onclick = newHandleA;
</script>
```

```js
/*
  假设需要在原有的项目的请求函数里添加一个 token 参数, 如果直接在 请求函数里直接修改就显得很僵硬
     如果以后这个请求函数再其他的项目也要使用, 可能就不需要 token, 这时就可以使用装饰器模式了
*/

  // 请求数据函数
  function ajax(type, url, params) {
      console.log('发送请求', type, url, params);
  }
  // 生成 token 函数
  function getToken() {
      return 'token';
  }
  // 未使用装饰器模式之前
  ajax('get', 'www.xxx.com', { name: '张三' }); // 发送请求 get www.xxx.com {name: '张三'}

  /*
      使用装饰器模式
          定义装饰器函数, 一定要定义在需要装饰的函数上, 因为要通过需要装饰的函数调用
          这样里面的 this 就是需要装饰的函数
  */
  ajax.before = function () {
      // 拿到需要装饰的函数 
      const self = this;
      // 需要返回的函数(装饰过的函数)
      const fn = function (type, url, params) {
          // 装饰一下函数(添加一个 token 参数)
          params.token = getToken();
          // 调用拿到的装饰的函数 
          self.call(this, type, url, params);
      }
      // 下面的代码可以让原函数不丢失本身的属性和原型对象
      fn.prototype = self.prototype;
      for (const [k,v] of Object.entries(self)) {
          fn[k] = v;
      }
      // 返回函数
      return fn;
  }
  // 将 ajax函数装饰一下
  ajax = ajax.before();
  // 使用装饰器模式之后
  ajax('get', 'www.xxx.com', { name: '张三' }); // 发送请求 get www.xxx.com {name: '张三', token: 'token'}
```

## 适配器模式
    当接口(方法)发生改变, 通过适配器, 来代替适配
    重写一个跟旧方法同名的方法 , 在里面调用更名后的方法 

```js
/* 
    例子:
        有俩个对象(谷歌对象和百度对象)分别有自己的渲染地图的接口方法
        这两个方法已经在项目中大量使用了
            直到有一天百度对象的渲染地图接口名从 show 改成 shouMap 了
            一个一个的从项目中修改不可取, 且容易出错
            这个时候就可以使用 适配器模式
*/

// 谷歌对象
const googleMap = {
    show: function () {
        console.log('开始渲染谷歌地图');
    }
};

// 百度对象
const baiduMap = {
    /* show: function () {
        console.log('开始渲染百度地图');
    }, */
    
    // baiduMap.show 改名了 baiduMap.showMap
    showMap: function () {
        console.log('开始渲染百度地图');
    }
};

// 适配器模式
// 重新写一个旧方法, 名字和改名前的方法一样, 再调用改名后的新方法
baiduMap.show = () => { baiduMap.showMap() };
```

## 享元模式
    享对象的模式。如果系统中出现大量相似度高，状态变化小的对象，可以尝试重用现有的同类对象来减少内存使用，达到性能优化

```js
/* 
    例子:
        有个服装厂, 现在的产品有50款男士和女士的衣服, 需要拍摄广告照片,
        一般情况下需要50个男模特和50个女模特, 然后让他们每人穿上一件衣服,
        进行拍照, 那样就需要创建100个对象就太浪费性能了 
        其实只需要1个男模特和1个女模特依次穿上所有的衣服进行拍照就可以
*/


// 模特类
class Model {
    constructor(sex) {
        this.sex = sex;
    }
    // 摄影方法
    photography(count) {
        for (let i = 0; i < count; i++) {
            console.log(`我是${this.sex}模特, 衣服${i + 1}号, 拍摄完毕`);
        }
    }
}
// 男模特
const femaleModel = new Model('female');
// 女模特
const maleModel = new Model('male');

// 男模特,女模特 分别调用拍摄方法即可
femaleModel.photography(50);
maleModel.photography(50);
```

## 观察者模式
    是一种一对多的关系, 当一个对象被修改时，则会自动通知观察着它的对象, 观察着的对象就可以作出反应

```js
/* 
    例子:
        学生坐在学校课室里上课

            学生是 被观察者

            老师是 观察者(观察学生上课的状态)
                一旦学生状态发生改变 上课 --> 睡觉
                老师就会作出对应的反应 --> 叫你家长来 ...
                ...
*/

// 观察者类
class Observer {
    constructor(name, fn) {
        // 名字
        this.name = name;
        // 行为
        this.fn = fn;
    }
}

// 被观察者类(学生)
class Subject {
    constructor(name, state) {
        // 名字
        this.name = name;
        // 状态
        this.state = state;
        // 存储观察者
        this.observerList = [];
    }
    // 添加观察者
    addObserver(obj) {
        // 过滤重复项
        this.observerList = this.observerList.filter(item => {
            return item.name !== obj.name;
        })
        // 添加观察者
        this.observerList.push(obj);
    }
    // 删除观察者
    delObserver(obj) {
        this.observerList = this.observerList.filter(item=>{
            return item !== obj;
        })
    }
    // 修改自己的状态并通知所有的观察者
    setState(state) {
        this.state = state;

        this.observerList.forEach(item => {
            // 把信息给他
            item.fn(this);
        })
    }
}

// 班主任
const bzr = new Observer('班主任', function ({ name, state }) {
    console.log(`因为${name}${state}, ${this.name}把你爸找来了`);
});
// 校长
const xz = new Observer('校长', function ({ name, state }) {
    console.log(`因为${name}${state}, ${this.name}骂你的班主任`);
});

// 实例一个学生小明
const xm = new Subject('小明', '上课');
// 添加班主任, 校长观察者
xm.addObserver(bzr);
xm.addObserver(xz);
// xm.delObserver(xz);
xm.setState('上课睡觉');
/* 
    因为小明上课睡觉, 班主任把你爸找来了
    因为小明上课睡觉, 校长骂你的班主任
*/

const xh = new Subject('小红', '上课');
xh.addObserver(bzr);
xh.setState('上课化妆'); // 因为小红上课化妆, 班主任把你爸找来了

```

## 发布订阅模式
    和观察者很像, 只不过是被观察者通过第三方来通知观察者, 使得观察者和被观察者之间完全解耦

```js
/* 
    例子:
        正常情况
        去书店买书, 问买xxx书, 没有, 回家
        过一会再去, 问买xxx书, 没有, 回家
        再过一会再去, 问买xxx书, 还是没有, 回家
        ...

        发布订阅模式
        去书店买书, 问买xxx书, 没有, 留下一个联系方式
        等有了店员就会联系通知我
        然后我就去买书
*/

// 第三方观察者类
class Observer {
    constructor() {
        // 消息队列
        this.message = {}
        /* 
            {
                买书: [fn1, fn2, fn3],
                xxx:  [fn1, fn2]
            }
        */
    }
    // 订阅消息
    on(type, fn) {
        // 判断有没有这个消息
        if (!this.message[type]) {
            // 第一次没有直接赋值数组
            this.message[type] = [];
        }
        // 添加消息
        this.message[type].push(fn);
    }
    /* 
        取消订阅消息
            第一种, 只传消息类型, 表示这个类型的消息全部取消订阅
            第二种, 传消息类型和对应的函数, 表示这个类型下的某个函数取消订阅
    */
    off(type, fn) {
        if(!this.message[type]) throw `没有这个消息 -->${type}`;


        // 删除整个消息类型的消息
        if(!fn){
            delete this.message[type];
            return;
        }

        // 删除消息类型里某一个通知
        this.message[type] = this.message[type].filter(item=>{
            return item !== fn;
        })
    }

    // 触发消息对象
    trigger(type) {
        if(!this.message[type]) throw `没有这个消息 -->${type}`;

        // 逐个触发消息
        this.message[type].forEach(item => {
            item();
        });
    }
}

// 实例小明
const xm = new Observer();
// 订阅消息
xm.on('动物世界', handleA); 
xm.on('三国演义', handleB);
xm.on('三国演义', handleC);


xm.trigger('动物世界'); // 动物世界书来了, 给你打电话

xm.trigger('三国演义');
/* 
    三国演义书来了, 给你打电话
    三国演义书来了, 给你发邮件
*/


// 太忙了, 接不到电话取消电话消息
xm.off('三国演义',handleB); 
xm.trigger('三国演义'); // 三国演义书来了, 给你发邮件

// 消息触发逻辑
function handleA(){
    console.log('动物世界书来了, 给你打电话');
}
function handleB(){
    console.log('三国演义书来了, 给你打电话');
}
function handleC(){
    console.log('三国演义书来了, 给你发邮件');
}
```

## 策略模式  
    一个问题匹配多个解决方案, 不一定要用到哪一个 (if-elseif分支过多)
    而且有可能会随时增加或减少解决方案

```js
/* 
    例子:
        购物商店打折
            618    打 7 折
            双11    打 6 折
            100_10  满 100 减 10
            300_25  满 300 减 25
            ...
        每次都一次一次算不太现实, 而且还不定时更换撤销
            这时就可以使用 策略模式
*/

// 可以通过闭包
const count = (function () {
    /*
        闭包缓存一个对象
            里面保存对应的打折计算方法
    */
    const methods = {
        "618": price => price * 0.7,
        "双11": price => price * 0.6,
        "100_10": price => price - 10,
    }

    // 专门负责操作闭包里的对象的函数
    function discount(type, price) {
        // 有没有对应的计算函数
        if (!methods[type]) throw `没有对应的折扣方案 --> ${type}`

        // 调用对应的计算函数
        return methods[type](price);
    }

    // 向闭包对象中添加方法
    discount.add = (type, fn) => {
        // 已存在对应的方法
        if (methods[type]) throw `已经存在对应的折扣方案 --> ${type}`;

        // 赋值传递进来的函数
        methods[type] = fn;
        console.log('添加',type);
    }
    // 向闭包对象中删除方法
    discount.del = type => {
        // 没有对应的方法
        if (!methods[type]) throw `没有这个折扣方案 --> ${type}`;

        // 删除对应的折扣方案
        delete methods[type];
        console.log('删除',type);
    }

    // 返回 discount 函数
    return discount;
})();


// 测试
console.log(count('618', 100)); // 70

// 添加满 300减25 
count.add("300_25",price => price - 25);
console.log(count('300_25', 300)); // 275

// 删除满 300减25 
count.del("300_25")

console.log(count('300_25', 300)); // Uncaught 没有对应的折扣方案 --> 300_25
```

## 责任链模式

    避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链
    当有请求发生时，可将请求沿着这条链传递，直到找到需要的对象来处理它为止

```js 
/* 
	例子:
        学校饭堂刷卡
            自己充的钱
            奖学金
            补助金
            这些钱虽然都可以刷但是性质是不一样的
                像自己充的钱可以退, 补助金不能退
                还有支付顺序等等...
*/

// 付款类
class Payment{
    constructor(balance){
        // 金额
        this.balance = balance;
        // 下一项支付类型
        this.next = null;
    }
    // 判断当前类型的金额是否充足
    isPay(amount){
        console.log('余额判断',this.balance);
        return this.balance >= amount;
    }
    // 支付对应的金额
    pay(amount){
        // 无法支付会调用链条下一项支付类型(记得return)
        if(!this.isPay(amount)){
            return this.next.pay(amount);
        }

        this.balance -= amount;
        console.log('支付后的余额',this.balance);
    }
    // 设置下一项要支付的方式
    setNext(payment){
        // // 没有下一项则不执行
        // if(!payment) return;

        return this.next = payment;
    }
}
// 自己充值的钱
const recharged = new Payment(100);
// 奖学金
const scholarship = new Payment(20);
// 补助金
const subvention = new Payment(200);

// 需要支付的金额
const amount = 80;

/*
    使用 else if 写的话顺序就写死了
*/ 

// 手动设置每一次的下一项支付方式是谁
// scholarship.setNext(subvention);
// subvention.setNext(recharged);

// 可以连着写(设置的时候有返回值)
scholarship
    .setNext(subvention)
    .setNext(recharged);

scholarship.pay(amount);
```

## 命令模式
    对命令进行封装，将发出命令的责任和执行命令的责任分割开
    命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递

```js
/* 
    例子:
        学校老师需要请假
            请假以后还需要
                全勤奖取消了
                还需要其他老师代课
                处理学生的作用
                ...
            假如快到请假了又不请假了
                那上面的逻辑又要取消

*/
// 老师信息
class Teacher {
    constructor() {
        // 是否全勤
        this.fullAttendence = true;
    }
}
// 老师相关的命令类
class LeaveCommand {
    constructor(teacher) {
        this.teacher = teacher;
    }
    do() {
        // 取消全勤
        this.teacher.fullAttendence = false;
        console.log('请假成功');
        console.log('取消全勤奖');
        console.log('安排代课老师');
        // ...
    }
    undo() {
        // 全勤将
        this.teacher.fullAttendence = true;
        console.log('取消请假成功');
        console.log('全勤奖');
        console.log('取消代课老师');
        // ...
    }
}

// 实例一个老师
const zm = new Teacher();
// 实例一个命令实例(传入老师对象)
const leave = new LeaveCommand(zm);

// 请假命令
leave.do();
// 取消请假命令
leave.undo();
```

## js的一些编码规范

- if嵌套问题

  ```
  尽可能早的返回代码
  if(...) return ...
  ```

- 代码复用

  ```
  任何执行两遍逻辑相同或类似的代码都可以封装
  ```

- 配置集中化

  ```
  程序配置相关的集中到一个文件下, 便于管理
  如: ajax 请求, 数据库连接配置等等
  ```

- 太长的逻辑条件

  ```
  应将每个条件独立一行, 逻辑运算符放置在行首或行尾进行分隔
  ```

- 变量相关

  - 变量命名

    ```
    变量名应当使用名词
    变量的命名方式:
            驼峰命名
            首字母大写
            中划线名
            下划线命名
    ```

  - 变量的初始化

    ```
    变量应该先声明, 然后再使用
    ```

  - 下划线的属性名

    ```
    带下划线的属性名一般表示私有方法
    ```

  - 大写的属性名

    ```
    大写的属性名一般表示常量
    ```
  - 构造函数首字母大写

    ```
    构造函数的首字母一般都是大写
    ```

- 注释

  ```
  注释要尽量简单, 清晰明了
  ```

  
:::
